# Способы модификации блока

В БЭМ-методологии блоки — это универсальные, повнорно используемые компоненты страницы. Но это не означает, что все блоки и БЭМ-проекты одинаковые. Каждый проект отличается от всех остальных, даже страницы в пределах одного портала содержат одинаковые компоненты, которые выглядят и ведут себя по-разному. Поэтому любые блоки в БЭМ можно изменять различными способами:

* [Модификатором](#Модификатором)
* [Контекстом](#Контекстом)
* [Уровнем переопределения](#Уровнем-переопределения)
* [Миксом](#Миксом)

Принципы модификации блока:

* ни один из способов не требует копровать код блока, а только затем изменять его.
* Работаем с одной и той же сущностью, просто модифицированной. В итоге у нас нет 100500 кнопок для разных случаев. Есть одна, которая доработана для каждого конкретного случая своим способом.

## Модификатором

Изменение блока производится при помощи установки/снятия модификатора, код которого описывает изменения. Блоку можно добавлять одновременно несколько модификаторов.

Модификатор может задавать блоку:

* [внешний вид](#Меняем-внешний-вид-блока)
* [состояние](#)
* [поведение](#Меняем-поведение-блока)
* [структуру](#Меняем-структуру-блока) (например, добавлять или удалять элементы)

> **Важно** Не создавайте новый блок, который незначительно отличается от уже существующего, добавьте модификатор.


### Примеры

Рассмотрим все случаи изменения блока с помощью модификатора на примере блока `button`.

Кнопка из библиотеки bem-components выглядит так:

По умолчанию фон у попапа осутствует.

```css
.popup{
	bacground: none;
}
```

```html
    <!-- Блок popup -->
    <div class="popup">...</div>
```

![Transparent popup]()


#### Меняем внешний вид блока 

Добавим блоку модификатор `theme` в значении `sun`, который создаст фон желтого цвета:

```files
project/
	blocks/
		popup/
			popup.js
			popup.css
			_theme/
				popup_theme_sun.css <!-- .popup{ bacground: yellow; }-->
```

```css
.popup{
	bacground: yellow;
}
```

```html
    <!-- Блок popup с модификатором theme в значении sun-->
    <div class="popup popup_theme_sun">...</div>
```

![Yellow background modificator for popup block]()

Модификатор `theme` в значении `forest` добавляет фон зеленого цвета:

```html
    <!-- Блок popup -->
    <div class="popup popup_theme_forest">...</div>
```

![Green background modificator for popup block]()


#### Меняем поведение блока

Добавим модификатор `direction`, который отвечает за направление отображения попапа.

Модификатор `direction` в значении `left` открывает попап влево:

```html
    <!-- Блок popup -->
    <div class="popup popup_direction_left">...</div>
```

![Left direction modificator for popup block]()

Модификатор `direction` в значении `right` открывает попап вправо:

```html
    <!-- Блок popup -->
    <div class="popup popup_direction_right">...</div>
```

![Right direction modificator for popup block]()


#### Меняем состояние блока


> [Правила описания булевых модификаторов](https://ru.bem.info/methodology/naming-convention/#Модификатор-блока)

#### Меняем структуру блока

Добавим модификатор `has-close` в значении `true`. У блока появляется элемент «закрывающий крестик». Также модификатор добавляет отступы блоку, освобождая место для крестика.

```html
    <!-- Блок popup -->
    <div class="popup popup_has-close">...</div>
```


![Modificator for adding close icon to popup]()

#### Добавляем несколько модификаторов 

Добавим модификтаоры:

* `theme` в значении `sun`;
* `direction` в значении `left`. 

```html
    <!-- Блок popup -->
    <div class="popup popup_theme_sun popup_direction_left">...</div>
```

Попап откроется влево и будет иметь желтый фон.

![Left direction modificator for yellow popup block]()


## Контекстом

Блок при размещении в другом блоке может менять свой внешний вид или поведение.

Пример
Цвет текста вложенного блока меняется с зеленого на красный, если он помещен в блок с синим фоном с красными буквами.

Примеры

Переключатель языков (b-lang-switcher)

Language switcher block
Переключатель языков (b-lang-switcher) в подвале страницы (b-foot), уменьшается размер шрифта.

b-lang-switcher with small text


## Уровнем переопределения

В БЭМ-методологии реализация блока может быть разделена по уровням переопределения. 

> [Как работают уровни переопределения]()

Изменения блока описываются на отдельном уровне переопределения, которые добавят (доопределеят) или изменят (переопределят) функциональность блока. Указать в настройках сборщика все используемые уровни.


Чтобы изменить блок, нужно на отдельном уровне переопределения описать изменения в коде, которые добавят (доопределеят) или изменят (переопределят) функциональность блока. Указать в настройках сборщика все используемые уровни.

Пример

Универсальные блоки из библиотеки должны выглядеть в разных проектах по-разному. Копировать код блока для каждого нового варианта использования нет смысла. Достаточно описать изменения блока на другом уровне переопределения в проекте и подключить этот уровень в сборку. 

Общая часть кода применится с уровня библиотеки и изменения — с уровня проекта.

> [Больше прмеров]()

## Миксом

[Миксы](../method/key-concepts.ru.md#Микс) позволяют добавлять блоку поведение и стили других БЭМ-сущностей. Чтобы примиксовать блоку новые свойства, необходимо разместить дополнительные БЭМ-сущности на одном DOM-узле с блоком.

С помощью миксов можно:
* [задавать внешнюю геометрию блока]()
* [изменять поведение и стили]()
 
### Пример

Предположим, 


Когда использовать микс, когда модификатор при изменении внешнего вида блока?
Микс используется, если блок имеет специфичное оформление только для данного случая и в данном виде больше не будет переиспользован в проекте.
Менять стили с 




если блок имеет специфичное оформление только для данного окружения и в данном виде точно не будет переиспользован на проекте.


По БЭМ-методологии блоки не должны ничего знать про свое позиционирование, так как могут быть использованы многократно в разных местах на странице. Например, блок `logo` может использоваться одновременно в шапке и в подвале страницы. Про то, что логотип имеет отступ в 22 пикселя от границы шапки должна знать только шапка (блок `header`), потому что у нее всегда задан такой отступ от края. А логотип, размещенный в подвале страницы (блок `footer`), может иметь другие отступы (например, 14 пикселей). Эти данные должны хранится в свойствах блока `footer`.



#### 
####
Внешняя геометрия и позиционирование
В CSS по БЭМ стили, отвечающие за внешнюю геометрию и позиционирование, задаются через родительский блок.

Пример

HTML-реализация:

<!-- Блок `header` -->
<header class="header">
    <button class="button">...</button>
</header>

<!-- Блок `form` -->
<form class="form" >
</form>
CSS-реализация кнопки:

.button {
    font-family: Arial, sans-serif;
    text-align: center;
    border: 1px solid black;    /* Рамка */
    margin: 30px;               /* Отступ */
}
Задача

Использовать кнопку из блока header в блоке form.

Блоку button установлен отступ в 30px, который может помешать его переиспользовать.

Решение выглядит следующим образом:

Пример

HTML-реализация:

<!-- Блок `header` -->
<header class="header">
    <!-- К блоку `button` примиксован элемент `button` блока `header` -->
    <button class="button header__button">...</button>
</header>

<!-- Блок `form` -->
<form class="form" >
    <button class="button">...</button>
</form>
CSS-реализация кнопки:

.button {
    font-family: Arial, sans-serif;
    border: 1px solid black;    /* Рамка */
}
CSS-реализация элемента button блока header:

.header__button {
    margin: 30px;
    position: relative;
}
В данном примере внешняя геометрия и позиционирование блока button задана через элемент header__button. Блок button стал независимым и универсальным, потому что не специфицирует никакие отступы.

Стилизация групп блоков
Иногда необходимо применить одинаковое форматирование сразу к нескольким различным HTML-элементам веб-страницы. Обычно для решения подобных задач применяют групповые селекторы.

Пример

HTML-реализация:

<article class="article"></article>

<footer class="footer">
    <div class="copyright"></div>
</footer>
CSS-реализация:

article, .footer div {
    font-family: Arial, sans-serif;
    font-size: 14px;
    color: #000;
}
В данном примере текст внутри блоков article и copyright имеет один и тот же цвет и шрифт.

Несмотря на то, что групповые селекторы позволяют быстро изменить дизайн страницы, такой подход увеличивает связанность кода.

Поэтому в БЭМ для того, чтобы единообразно отформатировать целый набор HTML-элементов, используют миксы.

Пример

HTML-реализация:

<article class="article text"></article>

<footer class="footer">
    <div class="copyright text"></div>
</footer>
CSS-реализация:

.text {
    font-family: Arial, sans-serif;
    font-size: 14px;
    color: #000;
}





1. Переопределения на уровнях
Если нам нужно, на некоторой странице иметь некий superInput, который чем-то отличается от базового input, то нам не обязательно именно придумывать новое имя и новый блок. Можно создать pages/index/blocks/input/input.js и положить туда BEM.DOM.decl('input', ... тут декларация полей и методов ...), эта декларация будет себя вести в точности как наследник базового blocks/input/input.js, т.е. будут доступны правильные this.__base() и this.__self.

2. Модификаторы
Поведение superInput базирующееся на базовом input можно представить как модификатор, например с именем type и значением super. В файле blocks/input/_type/input_type_super.js (который, кстати, можно создать командой bem create mod -l blocks -b input type -v super -T js) нужно написать BEM.DOM.decl({ block: 'input', modName: 'type', modVal: 'super'}, ... тут декларация полей и методов ...). Декларация полей и методов для модификатора также ведёт себя как наследник от базового класса, т.е. в методах доступны правильные this.__base() и this.__self.

3. Миксы
Мы можем выражать поведение элементов на странице с помощью смешивания нескольких БЭМ-сущностей на одной DOM-ноде. В HTML-е это будет выглядеть примерно так: . В BEMJSON так: { block: 'input', mix: [ { block: 'super-input' } ] }. После этого в коде блока blocks/super-input/super-input.js нет необходимости делать baseBlock, зато можно получить доступ к input с помощью метода this.findBlockOn('input') (документация в JSDoc).

4. Композиция блоков
Наконец можно просто использовать блок в составе другого блока, тут больше подходит пример с input и superForm. Можно вложить input внутрь superForm и из кода blocks/super-form/super-form.js можно будет получить доступ к input с помощью метода this.findBlockInside('input') (документация в JSDoc) и this.findBlocksInside('input') (документация в JSDoc).


Наследование в i-bem.js с помощью baseBlock мы реализовали скорее для полноты API и для того, чтобы было удобно делат некоторые i-* блоки, т.е. для функциональности внутри технологии JS. Этот способ не очень подходит для повторного использования БЭМ-сущностей в пределах всех технологий.

P.S. Так же рекомендую почитать критику объектно-ориентированного подхода вообще, например http://habrahabr.ru/post/143620/ .



нам писать лапидарный, структурированный и повторно используемый код.

Вскоре стало понятно, что возможность создавать повторно используемые бизнес компоненты это заблуждение. Каждый бизнес отличается от всех остальных, даже в одной отрасли. Каждый похожий проект работает по слишком специфичной бизнес логике.

Единственный способ сделать повторно используемые бизнес компоненты на этом уровне — сделать их сверх-настраиваемыми путём добавления таких штук как движки правил и встраиваемые языки.






Нарушение инкапсуляции


.b2 .b1__e1





для FAQ

когда делать собственные свойства блока когда отдельные?
https://github.com/bem-site/bem-forum-content-ru/issues/862
Q Просто показалось, что если блок не отвечает за свое позиционирование в потоке документа, то и за видимость тоже не отвечает
A Чтобы понять, какие свойства стоит сделать собственными, а какие — отдельными, нужно посмотреть на них с точки зрения реиспользования на другой странице/проекте.
Очевидно, что в зависимости от дизайна dropdown будет позиционироваться в разных местах, так что это свойство не является собственным. А вот возможность его скрыть/показать нужна всегда, стало быть, это его собственный модификатор.


когда микс когда модификатор
Q Всем привет. Сегодня на вебинаре на geekweekconf видел использование микса типа .page .page__home на тэге body, т.е. на одной дом-ноде и блок и элемент одновременно. Почему не используется модификатор?
A Потому что это разные по смыслу вещи — там нет задачи помодифицировать page. Причина такого микса в этом конкретном случае в том, что с точки зрения шаблонов page — это вся обвязка страницы, включая, доктайп, теги <html>, <head> и т.д., а page__body — это только <body>. При этом с точки зрения использования, скажем, в JavaScript, нам удобно иметь класс page на <body>.





