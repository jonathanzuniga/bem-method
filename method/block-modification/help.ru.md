
Микс используется, если блок имеет специфичное оформление только для данного случая и в данном виде больше не будет переиспользован в проекте.
Менять стили с 




если блок имеет специфичное оформление только для данного окружения и в данном виде точно не будет переиспользован на проекте.


По БЭМ-методологии блоки не должны ничего знать про свое позиционирование, так как могут быть использованы многократно в разных местах на странице. Например, блок `logo` может использоваться одновременно в шапке и в подвале страницы. Про то, что логотип имеет отступ в 22 пикселя от границы шапки должна знать только шапка (блок `header`), потому что у нее всегда задан такой отступ от края. А логотип, размещенный в подвале страницы (блок `footer`), может иметь другие отступы (например, 14 пикселей). Эти данные должны хранится в свойствах блока `footer`.



#### 
####
Внешняя геометрия и позиционирование
В CSS по БЭМ стили, отвечающие за внешнюю геометрию и позиционирование, задаются через родительский блок.

Пример

HTML-реализация:

<!-- Блок `header` -->
<header class="header">
    <button class="button">...</button>
</header>

<!-- Блок `form` -->
<form class="form" >
</form>
CSS-реализация кнопки:

.button {
    font-family: Arial, sans-serif;
    text-align: center;
    border: 1px solid black;    /* Рамка */
    margin: 30px;               /* Отступ */
}
Задача

Использовать кнопку из блока header в блоке form.

Блоку button установлен отступ в 30px, который может помешать его переиспользовать.

Решение выглядит следующим образом:

Пример

HTML-реализация:

<!-- Блок `header` -->
<header class="header">
    <!-- К блоку `button` примиксован элемент `button` блока `header` -->
    <button class="button header__button">...</button>
</header>

<!-- Блок `form` -->
<form class="form" >
    <button class="button">...</button>
</form>
CSS-реализация кнопки:

.button {
    font-family: Arial, sans-serif;
    border: 1px solid black;    /* Рамка */
}
CSS-реализация элемента button блока header:

.header__button {
    margin: 30px;
    position: relative;
}
В данном примере внешняя геометрия и позиционирование блока button задана через элемент header__button. Блок button стал независимым и универсальным, потому что не специфицирует никакие отступы.

Стилизация групп блоков
Иногда необходимо применить одинаковое форматирование сразу к нескольким различным HTML-элементам веб-страницы. Обычно для решения подобных задач применяют групповые селекторы.

Пример

HTML-реализация:

<article class="article"></article>

<footer class="footer">
    <div class="copyright"></div>
</footer>
CSS-реализация:

article, .footer div {
    font-family: Arial, sans-serif;
    font-size: 14px;
    color: #000;
}
В данном примере текст внутри блоков article и copyright имеет один и тот же цвет и шрифт.

Несмотря на то, что групповые селекторы позволяют быстро изменить дизайн страницы, такой подход увеличивает связанность кода.

Поэтому в БЭМ для того, чтобы единообразно отформатировать целый набор HTML-элементов, используют миксы.

Пример

HTML-реализация:

<article class="article text"></article>

<footer class="footer">
    <div class="copyright text"></div>
</footer>
CSS-реализация:

.text {
    font-family: Arial, sans-serif;
    font-size: 14px;
    color: #000;
}





1. Переопределения на уровнях
Если нам нужно, на некоторой странице иметь некий superInput, который чем-то отличается от базового input, то нам не обязательно именно придумывать новое имя и новый блок. Можно создать pages/index/blocks/input/input.js и положить туда BEM.DOM.decl('input', ... тут декларация полей и методов ...), эта декларация будет себя вести в точности как наследник базового blocks/input/input.js, т.е. будут доступны правильные this.__base() и this.__self.

2. Модификаторы
Поведение superInput базирующееся на базовом input можно представить как модификатор, например с именем type и значением super. В файле blocks/input/_type/input_type_super.js (который, кстати, можно создать командой bem create mod -l blocks -b input type -v super -T js) нужно написать BEM.DOM.decl({ block: 'input', modName: 'type', modVal: 'super'}, ... тут декларация полей и методов ...). Декларация полей и методов для модификатора также ведёт себя как наследник от базового класса, т.е. в методах доступны правильные this.__base() и this.__self.

3. Миксы
Мы можем выражать поведение элементов на странице с помощью смешивания нескольких БЭМ-сущностей на одной DOM-ноде. В HTML-е это будет выглядеть примерно так: . В BEMJSON так: { block: 'input', mix: [ { block: 'super-input' } ] }. После этого в коде блока blocks/super-input/super-input.js нет необходимости делать baseBlock, зато можно получить доступ к input с помощью метода this.findBlockOn('input') (документация в JSDoc).

4. Композиция блоков
Наконец можно просто использовать блок в составе другого блока, тут больше подходит пример с input и superForm. Можно вложить input внутрь superForm и из кода blocks/super-form/super-form.js можно будет получить доступ к input с помощью метода this.findBlockInside('input') (документация в JSDoc) и this.findBlocksInside('input') (документация в JSDoc).


Наследование в i-bem.js с помощью baseBlock мы реализовали скорее для полноты API и для того, чтобы было удобно делат некоторые i-* блоки, т.е. для функциональности внутри технологии JS. Этот способ не очень подходит для повторного использования БЭМ-сущностей в пределах всех технологий.

P.S. Так же рекомендую почитать критику объектно-ориентированного подхода вообще, например http://habrahabr.ru/post/143620/ .



нам писать лапидарный, структурированный и повторно используемый код.

Вскоре стало понятно, что возможность создавать повторно используемые бизнес компоненты это заблуждение. Каждый бизнес отличается от всех остальных, даже в одной отрасли. Каждый похожий проект работает по слишком специфичной бизнес логике.

Единственный способ сделать повторно используемые бизнес компоненты на этом уровне — сделать их сверх-настраиваемыми путём добавления таких штук как движки правил и встраиваемые языки.






Нарушение инкапсуляции


.b2 .b1__e1





для FAQ

когда делать собственные свойства блока когда отдельные?
https://github.com/bem-site/bem-forum-content-ru/issues/862
Q Просто показалось, что если блок не отвечает за свое позиционирование в потоке документа, то и за видимость тоже не отвечает
A Чтобы понять, какие свойства стоит сделать собственными, а какие — отдельными, нужно посмотреть на них с точки зрения реиспользования на другой странице/проекте.
Очевидно, что в зависимости от дизайна dropdown будет позиционироваться в разных местах, так что это свойство не является собственным. А вот возможность его скрыть/показать нужна всегда, стало быть, это его собственный модификатор.


когда микс когда модификатор
Q Всем привет. Сегодня на вебинаре на geekweekconf видел использование микса типа .page .page__home на тэге body, т.е. на одной дом-ноде и блок и элемент одновременно. Почему не используется модификатор?
A Потому что это разные по смыслу вещи — там нет задачи помодифицировать page. Причина такого микса в этом конкретном случае в том, что с точки зрения шаблонов page — это вся обвязка страницы, включая, доктайп, теги <html>, <head> и т.д., а page__body — это только <body>. При этом с точки зрения использования, скажем, в JavaScript, нам удобно иметь класс page на <body>.




